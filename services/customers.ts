/**
 * Customer Management Service
 * ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÅ‡∏ö‡∏ö‡∏Ñ‡∏£‡∏ö‡∏ß‡∏á‡∏à‡∏£ - ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡πâ‡∏≥
 */

import { db, auth } from '../firebase.config';
import {
    collection,
    doc,
    getDocs,
    setDoc,
    deleteDoc,
    query,
    where,
    orderBy,
    Timestamp,
    updateDoc,
} from 'firebase/firestore';

// Collection name
const CUSTOMERS_COLLECTION = 'customers';

// Interface ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Customer
export interface Customer {
    id?: string;
    companyId: string;          // ID ‡∏Ç‡∏≠‡∏á‡∏ö‡∏£‡∏¥‡∏©‡∏±‡∏ó‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ô‡∏µ‡πâ
    userId: string;             // User ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ô‡∏µ‡πâ
    
    // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å
    customerName: string;       // ‡∏ä‡∏∑‡πà‡∏≠‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤/‡∏ö‡∏£‡∏¥‡∏©‡∏±‡∏ó
    customerType: 'individual' | 'company';  // ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó: ‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏• ‡∏´‡∏£‡∏∑‡∏≠ ‡∏ô‡∏¥‡∏ï‡∏¥‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•
    
    // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠
    phone: string;              // ‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå‡∏´‡∏•‡∏±‡∏Å
    alternatePhone?: string;    // ‡πÄ‡∏ö‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏£‡∏≠‡∏á
    email?: string;             // ‡∏≠‡∏µ‡πÄ‡∏°‡∏•
    lineId?: string;            // Line ID
    
    // ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà
    address: string;            // ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏•‡∏±‡∏Å
    district?: string;          // ‡∏ï‡∏≥‡∏ö‡∏•/‡πÅ‡∏Ç‡∏ß‡∏á
    amphoe?: string;            // ‡∏≠‡∏≥‡πÄ‡∏†‡∏≠/‡πÄ‡∏Ç‡∏ï
    province?: string;          // ‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î
    postalCode?: string;        // ‡∏£‡∏´‡∏±‡∏™‡πÑ‡∏õ‡∏£‡∏©‡∏ì‡∏µ‡∏¢‡πå
    
    // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ò‡∏∏‡∏£‡∏Å‡∏¥‡∏à‡∏Å‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á/‡∏≠‡∏™‡∏±‡∏á‡∏´‡∏≤)
    projectName?: string;       // ‡∏ä‡∏∑‡πà‡∏≠‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£ (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
    houseNumber?: string;       // ‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà/‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà
    
    // Tags ‡πÅ‡∏•‡∏∞‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏
    tags?: string[];            // Tags ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏° ‡πÄ‡∏ä‡πà‡∏ô ['VIP', '‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏õ‡∏£‡∏∞‡∏à‡∏≥']
    notes?: string;             // ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
    
    // Metadata
    lastUsedAt?: Date;          // ‡πÉ‡∏ä‡πâ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏£ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö sorting)
    usageCount?: number;        // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö suggestion)
    createdAt?: Date;
    updatedAt?: Date;
}

/**
 * ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÉ‡∏´‡∏°‡πà
 */
export const saveCustomer = async (
    customer: Omit<Customer, 'id' | 'userId' | 'createdAt' | 'updatedAt' | 'usageCount'>,
    companyId?: string
): Promise<string> => {
    try {
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ user login ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
        const currentUser = auth.currentUser;
        if (!currentUser) {
            throw new Error('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤ Login ‡∏Å‡πà‡∏≠‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤');
        }
        
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á ID
        const docId = `customer_${Date.now()}_${customer.customerName.replace(/\s+/g, '_').toLowerCase()}`;
        const docRef = doc(db, CUSTOMERS_COLLECTION, docId);

        await setDoc(docRef, {
            ...customer,
            userId: currentUser.uid,
            companyId: companyId || customer.companyId,
            usageCount: 0, // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0
            createdAt: Timestamp.now(),
            updatedAt: Timestamp.now(),
        });

        console.log('‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à:', docId);
        return docId;
    } catch (error) {
        console.error('‚ùå Error saving customer:', error);
        throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ');
    }
};

/**
 * ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î - ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡∏≠‡∏á company ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
 * @param companyId - ID ‡∏Ç‡∏≠‡∏á‡∏ö‡∏£‡∏¥‡∏©‡∏±‡∏ó (required)
 */
export const getCustomers = async (companyId: string): Promise<Customer[]> => {
    try {
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ user login ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
        const currentUser = auth.currentUser;
        if (!currentUser) {
            throw new Error('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤ Login ‡∏Å‡πà‡∏≠‡∏ô‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤');
        }
        
        if (!companyId) {
            throw new Error('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ö‡∏£‡∏¥‡∏©‡∏±‡∏ó‡∏Å‡πà‡∏≠‡∏ô');
        }
        
        // Query: ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ö‡∏£‡∏¥‡∏©‡∏±‡∏ó‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° lastUsedAt
        const q = query(
            collection(db, CUSTOMERS_COLLECTION),
            where('companyId', '==', companyId),
            orderBy('lastUsedAt', 'desc')
        );

        const querySnapshot = await getDocs(q);
        const customers: Customer[] = querySnapshot.docs.map(doc => {
            const data = doc.data();
            return {
                id: doc.id,
                companyId: data.companyId,
                userId: data.userId,
                customerName: data.customerName,
                customerType: data.customerType,
                phone: data.phone,
                alternatePhone: data.alternatePhone,
                email: data.email,
                lineId: data.lineId,
                address: data.address,
                district: data.district,
                amphoe: data.amphoe,
                province: data.province,
                postalCode: data.postalCode,
                projectName: data.projectName,
                houseNumber: data.houseNumber,
                tags: data.tags || [],
                notes: data.notes,
                lastUsedAt: data.lastUsedAt?.toDate(),
                usageCount: data.usageCount || 0,
                createdAt: data.createdAt?.toDate(),
                updatedAt: data.updatedAt?.toDate(),
            } as Customer;
        });

        console.log(`üìã ‡∏û‡∏ö‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤ ${customers.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ ‡πÉ‡∏ô‡∏ö‡∏£‡∏¥‡∏©‡∏±‡∏ó ${companyId}`);
        return customers;
    } catch (error) {
        console.error('‚ùå Error getting customers:', error);
        throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ');
    }
};

/**
 * ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤
 */
export const searchCustomers = async (companyId: string, searchText: string): Promise<Customer[]> => {
    try {
        const allCustomers = await getCustomers(companyId);
        
        // Filter ‡∏î‡πâ‡∏ß‡∏¢ JavaScript
        const searchLower = searchText.toLowerCase();
        const filtered = allCustomers.filter(customer => 
            customer.customerName.toLowerCase().includes(searchLower) ||
            customer.phone.includes(searchText) ||
            (customer.projectName && customer.projectName.toLowerCase().includes(searchLower)) ||
            (customer.email && customer.email.toLowerCase().includes(searchLower))
        );

        console.log(`üîç ‡∏û‡∏ö ${filtered.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ "${searchText}"`);
        return filtered;
    } catch (error) {
        console.error('‚ùå Error searching customers:', error);
        throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ');
    }
};

/**
 * ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤
 */
export const updateCustomer = async (
    id: string,
    updates: Partial<Omit<Customer, 'id' | 'userId' | 'companyId' | 'createdAt' | 'updatedAt'>>
): Promise<void> => {
    try {
        const docRef = doc(db, CUSTOMERS_COLLECTION, id);
        await updateDoc(docRef, {
            ...updates,
            updatedAt: Timestamp.now(),
        });
        
        console.log('‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à:', id);
    } catch (error) {
        console.error('‚ùå Error updating customer:', error);
        throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ');
    }
};

/**
 * ‡∏•‡∏ö‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤
 */
export const deleteCustomer = async (id: string): Promise<void> => {
    try {
        const docRef = doc(db, CUSTOMERS_COLLECTION, id);
        await deleteDoc(docRef);
        
        console.log('‚úÖ ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à:', id);
    } catch (error) {
        console.error('‚ùå Error deleting customer:', error);
        throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ');
    }
};

/**
 * ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤ (‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤)
 * ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á suggestion ‡∏ó‡∏µ‡πà‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥
 */
export const updateCustomerUsage = async (id: string): Promise<void> => {
    try {
        const docRef = doc(db, CUSTOMERS_COLLECTION, id);
        
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        const customers = await getCustomers(''); // ‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏´‡πâ‡∏£‡∏±‡∏ö companyId
        const customer = customers.find(c => c.id === id);
        
        if (!customer) {
            throw new Error('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤');
        }
        
        await updateDoc(docRef, {
            lastUsedAt: Timestamp.now(),
            usageCount: (customer.usageCount || 0) + 1,
            updatedAt: Timestamp.now(),
        });
        
        console.log('‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à:', id);
    } catch (error) {
        console.error('‚ùå Error updating customer usage:', error);
        // ‡πÑ‡∏°‡πà throw error ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏Å
    }
};

/**
 * ‡∏î‡∏∂‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ö‡πà‡∏≠‡∏¢ (Top 10)
 */
export const getFrequentCustomers = async (companyId: string, limit: number = 10): Promise<Customer[]> => {
    try {
        const allCustomers = await getCustomers(companyId);
        
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° usageCount ‡∏à‡∏≤‡∏Å‡∏°‡∏≤‡∏Å‡πÑ‡∏õ‡∏ô‡πâ‡∏≠‡∏¢
        const sorted = allCustomers
            .filter(c => (c.usageCount || 0) > 0)
            .sort((a, b) => (b.usageCount || 0) - (a.usageCount || 0))
            .slice(0, limit);

        console.log(`‚≠ê ‡∏û‡∏ö‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ö‡πà‡∏≠‡∏¢ ${sorted.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
        return sorted;
    } catch (error) {
        console.error('‚ùå Error getting frequent customers:', error);
        return [];
    }
};

/**
 * ‡∏î‡∏∂‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î (Recent 10)
 */
export const getRecentCustomers = async (companyId: string, limit: number = 10): Promise<Customer[]> => {
    try {
        const allCustomers = await getCustomers(companyId);
        
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° lastUsedAt ‡∏à‡∏≤‡∏Å‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏õ‡πÄ‡∏Å‡πà‡∏≤
        const sorted = allCustomers
            .filter(c => c.lastUsedAt)
            .sort((a, b) => {
                const dateA = a.lastUsedAt?.getTime() || 0;
                const dateB = b.lastUsedAt?.getTime() || 0;
                return dateB - dateA;
            })
            .slice(0, limit);

        console.log(`üïí ‡∏û‡∏ö‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î ${sorted.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
        return sorted;
    } catch (error) {
        console.error('‚ùå Error getting recent customers:', error);
        return [];
    }
};

/**
 * ‡∏î‡∏∂‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ï‡∏≤‡∏° tags
 */
export const getCustomersByTags = async (companyId: string, tags: string[]): Promise<Customer[]> => {
    try {
        const allCustomers = await getCustomers(companyId);
        
        // ‡∏Å‡∏£‡∏≠‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏µ tags ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
        const filtered = allCustomers.filter(customer => 
            customer.tags && customer.tags.some(tag => tags.includes(tag))
        );

        console.log(`üè∑Ô∏è ‡∏û‡∏ö‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏µ tags ${tags.join(', ')}: ${filtered.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
        return filtered;
    } catch (error) {
        console.error('‚ùå Error getting customers by tags:', error);
        return [];
    }
};

